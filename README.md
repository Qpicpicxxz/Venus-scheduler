# Venus-scheduler

### This is a scheduler for VENUS: A Wireless Multi-core Processing Unit for 5G baseband
**动态返回值**

在通信基带处理系统中，可能会出现，在不同上层数据在处理的过程中，同一任务产生不同返回值的情况。而我们的数据流模型的DAG图是静态的，也就是调度器刚上电的时候就决定了每个任务对应了多少个返回值，因此，我们需要有一种处理动态个数的返回值的机制。现根据实际场景，我们约定动态的返回值情况分为如下三大类（DAG图中的task静态返回值个数为n，实际block运行后task动态返回值个数为m）：

- 多批次返回值`m >= n`：
  
  - 场景举例：多用户检测
    
  - 规则约束：`m % n = 0`
    
  - 操作需求：调度器需要将多个批次`batch = m / n`的数据一次传入后继fifo，因为一般情况下，一次task的返回值只会向其输出fifo中送入一个token，在此场景下需要激活**多次**后继。
    
- 动态依赖`m <= n`：
  
  - 场景举例：速率匹配
    
  - 规则约束：创建DAG图的时候需要例化最大可能数量的依赖
    
  - 操作需求：前继每一批次数据需要发射的速率匹配任务数量不同，且速率匹配task的后继，交织任务需要将每一批次的所有速率匹配任务的结果整合。在此场景下需要使交织任务依赖动态个数个速率匹配模块进行任务发射，这里为了保证数据流模型的一致性，我们采用伪**task**机制。其主要思想是每一次上级任务激活速率匹配模块的时候，往所有的后继fifo中都放入一个token，因为真正需要发射的速率匹配模块个数不确定，所以部分token是假例。这样做的好处能保证后继（交织任务）的发射判定标准与普通的actor判定标准一致。只需要在创建`ready_actor`的时候识别到伪`token`，并不实际激活相应的block，直接将此伪`token`送入后继即可。
    
- 常规返回`m = n`
